### README для библиотеки ViThreading

Библиотека **ViThreading** предоставляет продвинутые инструменты для управления многопоточностью в .NET 8.0. Основные компоненты решают ключевые проблемы параллельного программирования: динамическое управление ресурсами и приоритетное выполнение задач.

---

### Установка через NuGet
```bash
dotnet add package ViThreading
```

---

### Детальное описание компонентов

#### 1. `DynamicSemaphore`: Адаптивный семафор

**Решаемая проблема**:  
Традиционные семафоры в .NET имеют фиксированный лимит потоков. `DynamicSemaphore` позволяет изменять максимальное количество слотов во время работы приложения, что критично для сценариев с изменяющейся нагрузкой.

**Особенности реализации**:
```csharp
public class DynamicSemaphore
{
    // Установка/изменение лимита слотов
    public int MaximumCount { get; set; }

    // Занятые слоты
    public int UsedCount { get; }

    // Доступные слоты (не отрицательное значение)
    public int AvailableCount { get; }

    // Блокировка потока до получения слота
    public void WaitOne();

    // Попытка получения слота с таймаутом
    public bool TryWaitOne(int timeoutMs = 0);

    // Освобождение слота
    public void Release();
}
```

**Ключевые сценарии**:
- **Динамическое масштабирование**: Уменьшение лимита не прерывает текущие операции
  ```csharp
  var semaphore = new DynamicSemaphore(5);
  // Рабочая нагрузка...
  semaphore.MaximumCount = 2; // Плавное снижение пропускной способности
  ```
- **Аварийное ограничение**: Принудительная блокировка новых операций
  ```csharp
  semaphore.MaximumCount = 0; // Полная остановка новых запросов
  ```
- **Автоматическая нормализация**: После уменьшения лимита семафор самостоятельно восстанавливает корректное состояние по мере освобождения слотов

**Потокобезопасность**: Все операции защищены внутренними блокировками.

---

#### 2. `PriorityActionProcessor`: Планировщик задач с приоритетами

**Решаемая проблема**:  
Стандартные очереди задач .NET не поддерживают приоритетное выполнение и динамическое изменение размера пула потоков. Этот компонент обеспечивает:
- Выполнение задач по приоритету (меньшее число = выше приоритет)
- Динамическое масштабирование воркеров
- Централизованную обработку ошибок

**Архитектура**:
```csharp
public class PriorityActionProcessor : IDisposable
{
    // Текущее количество воркеров
    public int WorkerCount { get; }

    // Инициализация с указанием начального количества потоков
    public PriorityActionProcessor(int initialWorkers, 
                                  Action<Exception>? errorHandler = null);

    // Добавление задачи с приоритетом
    public void AddItem(Action item, int priority);

    // Изменение размера пула потоков
    public void SetWorkerCount(int newCount);
}
```

**Механизм работы**:
1. **Приоритетная очередь**: Использует `PriorityQueue<Action, int>` для сортировки задач
2. **Пулы воркеров**: Каждый воркер:
   - Бесконечно обрабатывает задачи из очереди
   - При отсутствии задач "засыпает" на 50 мс
   - Автоматически пробуждается при появлении новых задач
3. **Обработка ошибок**: Исключения в задачах перехватываются и передаются в глобальный обработчик

**Динамическое масштабирование**:
```csharp
// Увеличение пула (мгновенное)
processor.SetWorkerCount(8);

// Уменьшение пула (грациозное):
// 1. Инициирует отмену для лишних воркеров
// 2. Ожидает завершения текущих задач
// 3. Освобождает ресурсы
processor.SetWorkerCount(2);
```

**Критически важные особенности**:
- Приоритеты реализованы через стандартную очередь с приоритетами (.NET 6+)
- Гарантированное выполнение текущей задачи при уменьшении пула
- Автоматическая очистка ресурсов при вызове `Dispose()`

---

### Примеры использования

#### Сценарий 1: Адаптивный API-шлюз
```csharp
// Ограничение параллельных запросов с возможностью горячей настройки
var semaphore = new DynamicSemaphore(initialCount: 100);

app.Use(async (context, next) => {
    if (!semaphore.TryWaitOne(500))
    {
        context.Response.StatusCode = 429;
        return;
    }

    try { await next(); }
    finally { semaphore.Release(); }
});

// В админке
app.MapPost("/adjust-throttle", (int limit) => {
    semaphore.MaximumCount = limit; // Динамическое изменение
});
```

#### Сценарий 2: Обработка финансовых транзакций
```csharp
using var processor = new PriorityActionProcessor(4);

// Высокоприоритетные транзакции (клиенты Platinum)
processor.AddItem(() => ProcessTransaction(tx), priority: 1);

// Низкоприоритетные (аналитика)
processor.AddItem(() => GenerateReport(), priority: 100);

// Автомасштабирование при пиковой нагрузке
processor.SetWorkerCount(8); // Увеличение для Black Friday
```

---

### Тестирование и надежность
Библиотека включает 40+ тестов, проверяющих:
- **Граничные случаи** семафора:
  ```csharp
  // Тест: Уменьшение лимита ниже текущей нагрузки
  [Fact]
  public void ReduceMaxCount_BelowUsedCount_ShouldBlockNewWaiters()
  ```
- **Поведение приоритетов**:
  ```csharp
  // Тест: Гарантия порядка выполнения
  [Fact]
  public void PriorityOrder_HigherPriorityFirst()
  ```
- **Многопоточные сценарии**:
  ```csharp
  // Тест: 100 задач из 4 потоков
  [Fact]
  public async Task ConcurrentAdd_ProcessesAllItems()
  ```

Запуск тестов:
```bash
dotnet test
```

---

### Лицензия
**MIT License**  
Copyright (c) Virst

```text
Данная лицензия разрешает свободное использование, модификацию и распространение
библиотеки для любых целей при сохранении уведомления об авторских правах.
```

---

### Производительность и оптимизации
1. **Минимальные блокировки**: Использование `lock` только для критических секций
2. **Эффективная синхронизация**: `Monitor.PulseAll` для пробуждения ожидающих потоков
3. **Легковесные воркеры**: Каждый поток потребляет < 1 МБ памяти
4. **Оптимизированные коллекции**: Приоритетная очередь на базе `PriorityQueue`

---

### Поддержка и обратная связь
Отчеты об ошибках и запросы функций:  
[https://github.com/virst/ViThreading](https://github.com/virst/ViThreading)  
Техническая поддержка: mih-139@bk.ru
